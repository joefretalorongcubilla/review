<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Project Management Quiz</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --card: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #2563eb;
      --primary-weak: #dbeafe;
      --danger: #dc2626;
      --success: #059669;
      --border: #e5e7eb;
      --chip: #eef2ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background: var(--bg);
      line-height: 1.5;
    }
    .container {
      max-width: 980px;
      margin: 40px auto;
      padding: 0 16px;
    }
    .header {
      background: linear-gradient(180deg, var(--primary-weak), #fff);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    .header h1 {
      margin: 0 0 6px;
      font-size: 28px;
      letter-spacing: -0.02em;
    }
    .header p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    .q-title {
      font-weight: 600;
      margin-bottom: 8px;
    }
    .q-help {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 10px;
    }
    .choices { margin-top: 8px; }
    .choice {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      margin-bottom: 8px;
      background: #fff;
      transition: border-color .2s, background .2s;
    }
    .choice:hover { border-color: #c7d2fe; background: #fafbff; }
    .choice-label {
      width: 26px;
      min-width: 26px;
      height: 26px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      background: var(--chip);
      color: #4338ca;
      font-weight: 700;
      font-size: 14px;
    }
    .text-input, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      font-size: 14px;
      outline: none;
    }
    .text-input:focus, select:focus { border-color: #93c5fd; box-shadow: 0 0 0 3px #dbeafe; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f1f5f9;
      color: var(--muted);
      font-size: 12px;
      margin-left: 8px;
    }
    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    button {
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
    }
    button.primary {
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
    }
    button.ghost { background: transparent; }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .score {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      margin-bottom: 16px;
    }
    .score .badge {
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 8px;
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
      min-width: 70px;
      text-align: center;
    }
    .review.correct { border-color: #bbf7d0; background: #f0fdf4; }
    .review.incorrect { border-color: #fecaca; background: #fff1f2; }
    .review .title {
      font-weight: 700;
      margin-bottom: 4px;
    }
    .muted { color: var(--muted); }
    .pair-row {
      display: grid;
      grid-template-columns: 1fr 180px;
      gap: 10px;
      align-items: center;
      margin: 6px 0;
    }
    .subtitle {
      font-size: 13px;
      color: var(--muted);
      margin: 6px 0 12px;
    }
    .divider {
      height: 1px;
      background: var(--border);
      margin: 14px 0;
    }
    .legend {
      font-size: 12px;
      color: var(--muted);
    }
    .footnote {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 20px;
    }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Project Management Quiz</h1>
      <p>Includes True/False, Multiple Choice, Identification, Matching Type, Enumeration, and Acronyms. Your choices and the order of questions will shuffle on Retry.</p>
    </div>

    <div id="scoreBox" class="score hidden">
      <div class="badge" id="scoreBadge">0/0</div>
      <div>
        <div id="scoreText"><strong>Score:</strong> 0 out of 0</div>
        <div class="legend" id="legendText">Green = correct, Red = incorrect. Scroll below to review each item.</div>
      </div>
    </div>

    <div id="quiz"></div>

    <div class="btn-row">
      <button id="submitBtn" class="primary">Submit</button>
      <button id="retryBtn" class="ghost hidden">Retry & Shuffle</button>
    </div>

    <div id="reviewContainer" class="hidden"></div>

    <div class="footnote">This quiz is self-contained and runs entirely in your browser.</div>
  </div>

<script>
// =========================
// Utility: Shuffle (Fisher–Yates)
// =========================
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// =========================
// Question Bank
// =========================
// Types: 'truefalse', 'mcq', 'identification', 'matching', 'enumeration', 'acronym'
// Notes:
//  - MCQ: choices are shuffled per render; A-D labels remain fixed
//  - Identification/Acronym: case-insensitive match; trim; punctuation-insensitive
//  - Matching: dropdowns per left item using shuffled right options
//  - Enumeration: order-insensitive; matches any of accepted strings

const BASE_QUESTIONS = [
  // True/False
  {
    id: "tf1",
    type: "truefalse",
    text: "A project is a temporary endeavor undertaken to create a unique product, service, or result.",
    answer: true,
    points: 1
  },
  {
    id: "tf2",
    type: "truefalse",
    text: "In traditional waterfall, late requirement changes are easy and inexpensive to accommodate.",
    answer: false,
    points: 1
  },
  {
    id: "tf3",
    type: "truefalse",
    text: "Monitoring and controlling happen throughout the project, not just at the end.",
    answer: true,
    points: 1
  },
  {
    id: "tf4",
    type: "truefalse",
    text: "In Scrum, the ScrumMaster owns and prioritizes the product backlog.",
    answer: false, // Product Owner owns/prioritizes backlog
    points: 1
  },
  {
    id: "tf5",
    type: "truefalse",
    text: "Portfolio management groups projects and programs as enterprise investments.",
    answer: true,
    points: 1
  },

  // Multiple Choice
  {
    id: "mc1",
    type: "mcq",
    text: "Which set is commonly referred to as the triple constraint?",
    choices: [
      "Scope, Time, Cost",
      "Quality, Risk, Procurement",
      "Scope, Stakeholder, Communications",
      "Time, Human Resources, Cost"
    ],
    correctIndex: 0,
    points: 1
  },
  {
    id: "mc2",
    type: "mcq",
    text: "Who is primarily responsible for maximizing product value and managing the product backlog in Scrum?",
    choices: [
      "Product Owner",
      "ScrumMaster",
      "Project Sponsor",
      "Development Team"
    ],
    correctIndex: 0,
    points: 1
  },
  {
    id: "mc3",
    type: "mcq",
    text: "What does WBS stand for in project management?",
    choices: [
      "Work Breakdown Structure",
      "Workflow Baseline Schedule",
      "Weighted Budget Summary",
      "Work Benefit Scheme"
    ],
    correctIndex: 0,
    points: 1
  },
  {
    id: "mc4",
    type: "mcq",
    text: "Which process group focuses on measuring progress and managing variances?",
    choices: [
      "Monitoring and Controlling",
      "Initiating",
      "Executing",
      "Closing"
    ],
    correctIndex: 0,
    points: 1
  },
  {
    id: "mc5",
    type: "mcq",
    text: "In iterative and incremental development, products are built through:",
    choices: [
      "Repeated cycles and small portions to leverage learning",
      "A single linear pass from requirements to maintenance",
      "Only coding first, then documentation",
      "Big design up front without iterations"
    ],
    correctIndex: 0,
    points: 1
  },

  // Identification
  {
    id: "id1",
    type: "identification",
    text: "Identify the document that formally authorizes a project.",
    answers: ["project charter"],
    points: 1
  },
  {
    id: "id2",
    type: "identification",
    text: "Name the hierarchical deliverable-oriented decomposition of work to be executed by the project team.",
    answers: ["work breakdown structure", "wbs"],
    points: 1
  },
  {
    id: "id3",
    type: "identification",
    text: "Name the schedule analysis technique used to determine the longest path of activities and the shortest possible project duration.",
    answers: ["critical path method", "cpm", "critical path"],
    points: 1
  },
  {
    id: "id4",
    type: "identification",
    text: "Which agile framework uses short time-boxed iterations called sprints?",
    answers: ["scrum"],
    points: 1
  },

  // Matching Type
  {
    id: "match1",
    type: "matching",
    text: "Match each role to its primary responsibility.",
    left: [
      { key: "Product Owner", answer: "Owns backlog and maximizes product value" },
      { key: "ScrumMaster", answer: "Facilitates Scrum and removes impediments" },
      { key: "Project Sponsor", answer: "Provides resources and champions the project" },
      { key: "Project Manager", answer: "Plans, coordinates, and leads the project team" }
    ],
    rightOptions: [
      "Plans, coordinates, and leads the project team",
      "Provides resources and champions the project",
      "Owns backlog and maximizes product value",
      "Facilitates Scrum and removes impediments"
    ],
    points: 4 // 1 point per correct pair
  },

  // Enumeration
  {
    id: "enum1",
    type: "enumeration",
    text: "Enumerate the five project management process groups.",
    answers: [
      "initiating",
      "planning",
      "executing",
      "monitoring and controlling",
      "monitoring & controlling",
      "closing"
    ],
    requiredCount: 5,
    points: 5 // 1 point per correct unique item up to requiredCount
  },

  // Acronyms
  {
    id: "acr1",
    type: "acronym",
    text: "Expand the acronym PMBOK.",
    answers: ["project management body of knowledge"],
    points: 1
  },
  {
    id: "acr2",
    type: "acronym",
    text: "Expand the acronym EVM.",
    answers: ["earned value management"],
    points: 1
  }
];

// =========================
// Render Helpers
// =========================

// Normalize strings for comparison
function norm(s) {
  return (s || "")
    .toString()
    .trim()
    .toLowerCase()
    .replace(/[.\-_,;:!?()]/g, "")
    .replace(/\s+/g, " ");
}

// Generate letter labels A, B, C, D, ...
function letterAt(i) {
  return String.fromCharCode("A".charCodeAt(0) + i);
}

// Build the quiz state with shuffled questions and (for MCQ and Matching) shuffled options
function buildState() {
  const questions = shuffle(BASE_QUESTIONS);
  const state = questions.map(q => {
    if (q.type === "mcq") {
      const idxs = Array.from({length: q.choices.length}, (_, i) => i);
      const shuffledIdxs = shuffle(idxs);
      // map shuffled choices into A, B, C, D slots
      const mapped = shuffledIdxs.map(i => ({ text: q.choices[i], origIndex: i }));
      return { ...q, _choiceMap: mapped };
    }
    if (q.type === "matching") {
      return { ...q, _rightShuffled: shuffle(q.rightOptions) };
    }
    return { ...q };
  });
  return state;
}

let QUIZ_STATE = buildState();

function renderQuiz() {
  const quiz = document.getElementById("quiz");
  quiz.innerHTML = "";

  QUIZ_STATE.forEach((q, idx) => {
    const card = document.createElement("div");
    card.className = "card";
    card.id = `q-${q.id}`;

    const title = document.createElement("div");
    title.className = "q-title";
    title.textContent = `${idx + 1}. ${q.text}`;

    const meta = document.createElement("div");
    meta.className = "q-help";
    meta.textContent = typeHelp(q);

    card.appendChild(title);
    card.appendChild(meta);

    // Render by type
    if (q.type === "truefalse") {
      const wrap = document.createElement("div");
      wrap.className = "choices";
      ["True", "False"].forEach((label, i) => {
        const row = document.createElement("label");
        row.className = "choice";
        const badge = document.createElement("div");
        badge.className = "choice-label";
        badge.textContent = letterAt(i);
        const input = document.createElement("input");
        input.type = "radio";
        input.name = q.id;
        input.value = label.toLowerCase();
        input.style.marginTop = "4px";
        const span = document.createElement("div");
        span.textContent = label;
        row.appendChild(badge);
        row.appendChild(input);
        row.appendChild(span);
        wrap.appendChild(row);
      });
      card.appendChild(wrap);
    }

    if (q.type === "mcq") {
      const wrap = document.createElement("div");
      wrap.className = "choices";
      q._choiceMap.forEach((c, i) => {
        const row = document.createElement("label");
        row.className = "choice";
        const badge = document.createElement("div");
        badge.className = "choice-label";
        badge.textContent = letterAt(i);
        const input = document.createElement("input");
        input.type = "radio";
        input.name = q.id;
        input.value = i; // index in displayed map
        input.style.marginTop = "4px";
        const span = document.createElement("div");
        span.textContent = c.text;
        row.appendChild(badge);
        row.appendChild(input);
        row.appendChild(span);
        wrap.appendChild(row);
      });
      card.appendChild(wrap);
    }

    if (q.type === "identification" || q.type === "acronym") {
      const input = document.createElement("input");
      input.className = "text-input";
      input.type = "text";
      input.placeholder = "Type your answer";
      input.dataset.qid = q.id;
      card.appendChild(input);
    }

    if (q.type === "matching") {
      const sub = document.createElement("div");
      sub.className = "subtitle";
      sub.textContent = "Select the best match for each left-side item.";
      card.appendChild(sub);

      q.left.forEach((pair, i) => {
        const row = document.createElement("div");
        row.className = "pair-row";
        const leftLabel = document.createElement("div");
        leftLabel.textContent = pair.key;
        const select = document.createElement("select");
        select.dataset.qid = q.id;
        select.dataset.leftKey = pair.key;
        const defaultOpt = document.createElement("option");
        defaultOpt.value = "";
        defaultOpt.textContent = "— Select —";
        select.appendChild(defaultOpt);
        q._rightShuffled.forEach(opt => {
          const o = document.createElement("option");
          o.value = opt;
          o.textContent = opt;
          select.appendChild(o);
        });
        row.appendChild(leftLabel);
        row.appendChild(select);
        card.appendChild(row);
      });
    }

    if (q.type === "enumeration") {
      const sub = document.createElement("div");
      sub.className = "subtitle";
      sub.textContent = `Provide ${q.requiredCount} distinct items. Order does not matter.`;
      card.appendChild(sub);
      for (let i = 0; i < q.requiredCount; i++) {
        const input = document.createElement("input");
        input.className = "text-input";
        input.type = "text";
        input.placeholder = `Item ${i + 1}`;
        input.dataset.qid = q.id;
        card.appendChild(input);
      }
    }

    quiz.appendChild(card);
  });
}

function typeHelp(q) {
  switch (q.type) {
    case "truefalse": return "True or False";
    case "mcq": return "Multiple Choice. Choices are shuffled; labels A–D stay fixed.";
    case "identification": return "Identification";
    case "acronym": return "Acronym Expansion";
    case "matching": return "Matching Type";
    case "enumeration": return "Enumeration";
    default: return "";
  }
}

// =========================
// Submission, Scoring, Review
// =========================
function collectAndScore() {
  let score = 0;
  let total = 0;
  const reviewBlocks = [];

  QUIZ_STATE.forEach((q, idx) => {
    let correct = false;
    let userDisplay = "";
    let correctDisplay = "";

    if (q.type === "truefalse") {
      total += q.points;
      const sel = document.querySelector(`input[name="${q.id}"]:checked`);
      const ans = sel ? sel.value : null;
      const isTrue = ans === "true";
      correct = (isTrue === q.answer);
      userDisplay = sel ? sel.value : "(no answer)";
      correctDisplay = q.answer ? "true" : "false";
      if (correct) score += q.points;
    }

    if (q.type === "mcq") {
      total += q.points;
      const sel = document.querySelector(`input[name="${q.id}"]:checked`);
      let userChoiceText = "(no answer)";
      if (sel) {
        const idxInMap = parseInt(sel.value, 10);
        if (!isNaN(idxInMap) && q._choiceMap[idxInMap]) {
          userChoiceText = q._choiceMap[idxInMap].text;
        }
      }
      const correctChoiceInMap = q._choiceMap.findIndex(x => x.origIndex === q.correctIndex);
      correct = sel && parseInt(sel.value, 10) === correctChoiceInMap;
      userDisplay = userChoiceText;
      correctDisplay = q._choiceMap[correctChoiceInMap].text;
      if (correct) score += q.points;
    }

    if (q.type === "identification" || q.type === "acronym") {
      total += q.points;
      const input = document.querySelector(`input[data-qid="${q.id}"]`);
      const val = input ? input.value : "";
      const valN = norm(val);
      const answersN = (q.answers || []).map(norm);
      correct = answersN.includes(valN);
      userDisplay = val || "(no answer)";
      correctDisplay = q.answers.join(" / ");
      if (correct) score += q.points;
    }

    if (q.type === "matching") {
      // 1 point per correct pair
      let localScore = 0;
      const rightsByKey = {};
      q.left.forEach(p => rightsByKey[p.key] = p.answer);
      q.left.forEach(p => {
        const sel = document.querySelector(`select[data-qid="${q.id}"][data-left-key="${p.key}"]`);
        const val = sel ? sel.value : "";
        if (norm(val) === norm(rightsByKey[p.key])) {
          localScore += 1;
        }
      });
      score += localScore;
      total += q.points; // q.points equals number of pairs
      userDisplay = `Pairs correct: ${localScore}/${q.left.length}`;
      correctDisplay = "All correct mappings shown in the card above.";
      // We'll also expand per-pair details in the review block
      const perPairs = q.left.map(p => {
        const sel = document.querySelector(`select[data-qid="${q.id}"][data-left-key="${p.key}"]`);
        const val = sel ? sel.value : "";
        const ok = norm(val) === norm(p.answer);
        return { key: p.key, chosen: val || "(no selection)", answer: p.answer, ok };
      });
      reviewBlocks.push(renderMatchReview(q, idx, perPairs));
      return; // already pushed custom block; skip the generic block
    }

    if (q.type === "enumeration") {
      // 1 point per correct unique item up to requiredCount
      const inputs = Array.from(document.querySelectorAll(`input[data-qid="${q.id}"]`));
      const vals = inputs.map(i => norm(i.value)).filter(Boolean);
      const uniqVals = Array.from(new Set(vals));
      const answersN = (q.answers || []).map(norm);
      let hits = 0;
      uniqVals.forEach(v => {
        if (answersN.includes(v)) hits += 1;
      });
      const localScore = Math.min(hits, q.requiredCount);
      score += localScore;
      total += q.points;
      userDisplay = `${hits} correct out of ${q.requiredCount}`;
      correctDisplay = "Accepted answers include: " + (q.answers || []).join(", ");
    }

    // Generic per-question review block
    reviewBlocks.push(renderReview(q, idx, correct, userDisplay, correctDisplay));
  });

  return { score, total, reviewBlocks };
}

function renderReview(q, idx, correct, userDisplay, correctDisplay) {
  const wrap = document.createElement("div");
  wrap.className = `card review ${correct ? "correct" : "incorrect"}`;

  const title = document.createElement("div");
  title.className = "title";
  title.textContent = `${idx + 1}. ${q.text}`;
  const you = document.createElement("div");
  you.innerHTML = `<strong>Your answer:</strong> ${escapeHTML(userDisplay)}`;
  const corr = document.createElement("div");
  corr.innerHTML = `<strong>Correct answer:</strong> ${escapeHTML(correctDisplay)}`;

  wrap.appendChild(title);
  wrap.appendChild(you);
  wrap.appendChild(corr);
  return wrap;
}

function renderMatchReview(q, idx, perPairs) {
  const wrap = document.createElement("div");
  // global correctness if all pairs ok
  const allOk = perPairs.every(p => p.ok);
  wrap.className = `card review ${allOk ? "correct" : "incorrect"}`;
  const title = document.createElement("div");
  title.className = "title";
  title.textContent = `${idx + 1}. ${q.text}`;

  const table = document.createElement("div");
  table.className = "subtitle";
  table.textContent = "Per-pair results:";

  wrap.appendChild(title);
  wrap.appendChild(table);
  perPairs.forEach(p => {
    const row = document.createElement("div");
    row.style.margin = "6px 0";
    row.innerHTML = `<strong>${escapeHTML(p.key)}</strong> → You: ${escapeHTML(p.chosen)} | Correct: ${escapeHTML(p.answer)}`;
    wrap.appendChild(row);
  });
  return wrap;
}

function escapeHTML(s) {
  return (s+"")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// Disable inputs after submit
function setInputsDisabled(disabled) {
  const inputs = document.querySelectorAll("input, select");
  inputs.forEach(el => el.disabled = disabled);
}

// =========================
// Handlers
// =========================
function onSubmit() {
  const { score, total, reviewBlocks } = collectAndScore();
  const scoreBox = document.getElementById("scoreBox");
  const badge = document.getElementById("scoreBadge");
  const text = document.getElementById("scoreText");
  const review = document.getElementById("reviewContainer");

  badge.textContent = `${score}/${total}`;
  text.innerHTML = `<strong>Score:</strong> ${score} out of ${total}`;
  scoreBox.classList.remove("hidden");

  review.innerHTML = "";
  reviewBlocks.forEach(b => review.appendChild(b));
  review.classList.remove("hidden");

  setInputsDisabled(true);
  document.getElementById("submitBtn").classList.add("hidden");
  document.getElementById("retryBtn").classList.remove("hidden");
}

function onRetry() {
  // Rebuild state with new shuffles, re-render
  QUIZ_STATE = buildState();
  renderQuiz();

  // Reset UI
  const scoreBox = document.getElementById("scoreBox");
  const review = document.getElementById("reviewContainer");
  scoreBox.classList.add("hidden");
  review.classList.add("hidden");
  review.innerHTML = "";

  setInputsDisabled(false);
  document.getElementById("submitBtn").classList.remove("hidden");
  document.getElementById("retryBtn").classList.add("hidden");
}

// =========================
// Init
// =========================
document.addEventListener("DOMContentLoaded", () => {
  renderQuiz();
  document.getElementById("submitBtn").addEventListener("click", onSubmit);
  document.getElementById("retryBtn").addEventListener("click", onRetry);
});
</script>
</body>
</html>